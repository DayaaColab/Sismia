# -*- coding: utf-8 -*-
"""Código Sismos Ecuador.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gGAHUms9cm4sa_vAsAm-wvQiMwJ_zFcS
"""



pip install streamlit -q

pip install streamlit-lottie

pip install pillow

# Commented out IPython magic to ensure Python compatibility.

# %config IPCompleter.greedy=True
import pandas as pd
import numpy as np
import xlrd
import seaborn as sb
import matplotlib.pyplot as plt
from matplotlib.ticker import PercentFormatter

from google.colab import data_table

from google.colab import files

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
from google.colab import data_table
data_table.enable_dataframe_formatter()

# Read CSV file with space delimiter
df = pd.read_csv('/content/drive/MyDrive/IGNEA-PYTHON/data_sismos_Ecuador1.csv',  sep=";")


# Print the first 5 rows of the data frame
display(df)

"""Pre-procesamiento

"""

new_column_names = ["Día","Mes","Año", "Hora (UTM)","Latitud(deg)", "Longitud(deg)", "Profundidad(km)","Magnitud media","Magnitud Principal",
                    "Tipo de Magnitud", "GapAzimutal" , "DistMax", "DisMin"]

df.columns = new_column_names
display(df)

df.info()

file_name = 'sismos_data2_processed.xlsx'

# saving the excel
df.to_excel(file_name)
print('DataFrame is written to Excel File successfully.')

"""GRÁFICA DEL SISMO SEGÚN EL MES



"""

import plotly.express as px
fig = px.histogram(df, x="Mes")
fig.show()

"""Año dónde ocurrieron mayor cantidad de sismos

"""

import plotly.express as px
fig = px.histogram(df, x="Año")
fig.show()

"""PROFUNDIDAD DE LOS SISMOS

"""

df.describe()['Magnitud Principal']

plt.hist(df['Magnitud Principal'],bins = [x for x in range(0,200,70)])
plt.title('Profunidad del sismo')
plt.xlabel('Profundidad (Km)')
plt.ylabel('Número de sismos')

import plotly.express as px
fig = px.histogram(df, x="Profundidad(km)")
fig.show()

import plotly.express as px
fig = px.histogram(df, x="Magnitud Principal")
fig.show()

from IPython.display import Javascript
display(Javascript('''
  google.colab.widgets.installCustomManager('https://ssl.gstatic.com/colaboratory-static/widgets/colab-cdn-widget-manager/6a14374f468a145a/manager.min.js');
'''))

pip install keplergl

from google.colab import output
output.enable_custom_widget_manager()

from keplergl import KeplerGl
map_1 = KeplerGl(height = 600)
map_1.add_data(data=df, name = 'Earthquakes Visualization')

map_1

df2 = pd.read_csv('/content/drive/MyDrive/IGNEA-PYTHON/data_sismos_Ecuador1.csv',  sep=";")

map_1.add_data(data = df2, name = 'Earthquakes')

map_1.data

map_1.save_to_html(file_name= 'Heatmap_Earthquakes.html')

"""Dividir los datos en datos de entrenamiento y prueba

"""

from sklearn.model_selection import train_test_split

# Columnas relevantes
X = df[['Longitud(deg)','Latitud(deg)', 'Profundidad(km)']]
y = df['Magnitud Principal']

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0)

"""**REGRESIÓN LINEAL**

Cargar el modelo y ajustarlo con datos de entrenamiento
"""

from sklearn.linear_model import LinearRegression
# Entrenar el modelo de regresión lineal
regressor = LinearRegression()
regressor.fit(X_train, y_train)

"""
**Predecir los datos de prueba**

Encontrar los valores que han sido pronosticados y evaluarlos en la regresión lineal."""

from sklearn.metrics import r2_score, mean_squared_error

scores= {"Nombre del modelo": ["Regresión Lineal", "Random Forest"], "mse": [], "R^2": []}
# Predecir en el conjunto de prueba
y_pred = regressor.predict(X_test)

#  R^2 y MSE
r2 = r2_score(y_test, y_pred)
mse = mean_squared_error(y_test, y_pred)

scores['mse'].append(mse)
scores['R^2'].append(r2)

print("R^2: {:.3f}, MSE: {:.3f}".format(r2, mse))

"""**PREDICCIÓN - NUEVOS DATOS**

"""

# Nuevos datos
new_data = [[-78.236176,-1.687624,95.13], [-79.480726,-3.031121,155.81]]
new_pred = regressor.predict(new_data)
print("Nuevas predicciones:", new_pred)

"""**Modelo de regresión lineal múltiple**

"""

import seaborn as sns
import matplotlib.pyplot as plt

# Graficar la línea de regresión
sns.regplot(x=X_test['Longitud(deg)'], y=y_test, color='blue', scatter_kws={'s': 8})
sns.regplot(x=X_test['Latitud(deg)'], y=y_test, color='green', scatter_kws={'s': 8})
sns.regplot(x=X_test['Profundidad(km)'], y=y_test, color='red', scatter_kws={'s': 8})
plt.legend(labels=['Longitud(deg)','Latitud(deg)', 'Profundidad(km)'])
plt.xlabel('Variables Predictoras')
plt.ylabel('Magnitud Principal')
plt.title('Modelo de regresión lineal múltiple')
plt.show()

"""**RANDOM FOREST**

"""

from sklearn.ensemble import RandomForestRegressor

#  bosque aleatorio con 100 árboles
rf = RandomForestRegressor(n_estimators=200, random_state=42)

# Ajustar el regresor a los datos de entrenamiento
rf.fit(X_train, y_train)

"""Predecir los datos de prueba y evaluarlos

"""

# Predecir la variable objetivo en los datos de prueba
y_pred = rf.predict(X_test)

# Evaluar el error cuadrático medio y  R^2
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

scores['mse'].append(mse)
scores['R^2'].append(r2)

print('Mean Squared Error: ', mse)
print('R^2 Score: ', r2)

"""**MODELO**

"""

# Trazar los valores pronosticados y reales
plt.scatter(y_test, y_pred)
plt.xlabel('Magnitud actual')
plt.ylabel('Magnitud predicha')
plt.title('Random Forest - Resultados de la Regresión')
plt.show()

import seaborn as sns
sns.residplot(x= y_test, y =y_pred, color='orange')
plt.xlabel('Magnitud Predicha')
plt.ylabel('Residual')
plt.title('Gráfica Residual')
plt.show()

plt.plot(y_test.index[:20], y_test[:20], color='blue', label='Magnitud actual')
plt.plot(y_test.index[:20], y_pred[:20], color='orange', label='Magnitud predicha')
plt.xlabel('Index')
plt.ylabel('Magnitud Principal')
plt.title('Actual vs. Predicha')
plt.legend()
plt.show()

from sklearn.svm import SVR

# Select a subset of the training data
subset_size = 900
X_train_subset = X_train[:subset_size]
y_train_subset = y_train[:subset_size]

# Create an SVM model
svm = SVR(kernel='rbf', C=1e3, gamma=0.1)

# Train the SVM model on the subset of data
svm.fit(X_train_subset, y_train_subset)

# Evaluate the model on the test set
score = svm.score(X_test, y_test)
print("Test score:", score)

"""Predecir los datos de prueba
Encuentre los valores predichos y evalúelos usando métricas como MSE, r2

"""

# Predict on the testing set
y_pred_svm = svm.predict(X_test)

# Compute R^2 and MSE
r2_svm = r2_score(y_test, y_pred_svm)
mse_svm = mean_squared_error(y_test, y_pred_svm)

scores['mse'].append(mse_svm)
scores['R^2'].append(r2_svm)
print("SVM R^2: {:.2f}, MSE: {:.2f}".format(r2_svm, mse_svm))

# Predicción de los nuevos datos
new_pred_svm = svm.predict(new_data)
print("Nuevas predicciones con SVM:", new_pred_svm)